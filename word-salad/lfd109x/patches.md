---
icon: git-alt
---

# Patches

When a developer makes modifications and wants to contribute them to the project, there are two basic methods of doing so:

1. Arrange to have their development branch pulled into the `master`, or push them into the `master` branch.
2. Produce a series of one or more `patches`, which a maintainer can then apply to the source with the `patch` utility.

Nowadays, the first method is more common, but patches can still be supplied, especially for simple changes. One can have Git itself produce them in an immaculate form. Anyone with an email client must not have Git repositories installed to submit their patches to the maintainers.

Let's learn how to do this properly!

## Overview

* Understand the role of patches in the use of Git.
* Know how to generate and format a patch properly so it can be reviewed and hopefully accepted
* Know how to create a patch through the use of `diff`
* Know how to create a patch through `git format-patch`, which is a better method
* Understand how to format a patch through email, either through your usual email client or through `git send-email`
* Apply a patch that is sent to you.

### Why Use Patches?

Git is a peer-to-peer system designed to allow changes to flow back and forth between developers and repositories using `push`-and-`pull` operations.

It works efficiently using its  `git://` protocol as well, `http://` and `ssh://` protocols. However, there are times when it is either necessary or desired to submit changes via a more conventional patch mechanism, generally through email.

The first reason for doing this is to encourage review before changes are merged. There are well-established mailing lists and discussion groups for many projects, such as the Linux Kernel. Enabling more eyeballs to view the patch, suggest or make changes, and test before final submission can improve development.

The second reason is that even if developers are using Git, interference, such as corporate firewalls, may prevent them from using Git, SSH, and even HTTP. Email is likely to provide a method for bypassing these restrictions.

Fortunately, Git has all the built-in infrastructure for handling patches and direct emailing.

A brief review of the `patch` utility and its relation  `diff` is in order. Suppose you have a directory tree named `devel` based on a directory tree `stable` and have made some changes. A patch file is generated by doing the following:

```bash
$ diff -Nur stable_tree modified_tree > /path/to/my_patch
```

{% hint style="warning" %}
The `-N` option means include files that have been added or removed in the patch; `-u` means a unified difference and `-r` means recursive.
{% endhint %}

If you want to compare two individual files named `original` and `modified` you need to do:

```bash
$ diff -u original_file modified_file > /path/to/my_patch
```

To apply the patch to the stable directory tree, another developer has to do the following:

```bash
$ cd stable ; patch -p1 < /path/to/my_patch
```

where the `-p1` option indicates that the patch was made while sitting one directory up.

### Producing Patches

When using git directly, generating patches in the correct form is very simple and uses only basic commands. For example, if you want to produce a patch including all changes since your last commit, you can do the following:

```bash
$ git diff > patch_file
```

and save the output in a patch file (of course, you can also get a `diff` between two commits or two tags, etc.).

You can also produce patches in other ways with more fine-grained control. The basic command for producing patches is `git format-patch`. The arguments that are given control which and how many patches are produced.

For example, doing:

```bash
$ git format-patch -3
```

Will produce a patch file for each of the last three commits, with names like:

```shell
0001-This-is-the-first-commit.patch
0002-This-is-the-second-commit.patch
```

where the names are generated from the commit messages and are ordered in historical sequence, each patch will cover all files that have been changed in the commit in one patch.

You can also do something like:

```bash
$ git format-patch main
```

To get all changes since the branch off of the main branch. You can use any kind of commit identifier or tag, and you can also specify a range of commits.

There are plenty of other options. A good one to use is `--signoff` or `-s` which adds a line in the form of:

```bash
Signed-off-by: A Smart Guy <asmartguy@linux.com>
```

According to the settings in your configuration file. This creates a clear trail of who contributed what and is mandatory in some projects, such as the Linux kernel.

### Emailing

Not surprisingly, the command to directly email a patch is `git send-email`. To send a message to the Linux kernel mailing list, you would do:

```bash
$ git send-email -to linux-kernel@vger.kernel.org 0001-This-is-the-first-commit.patch
```

When doing this, you will be prompted for information, such as who the message is coming from. Additional information, such as your SMTP mail agent configuration, can also be specified, as can additional recipients of the emailed patch.

Whether or not this will work without adjustment to your system's mail setup (such as a possible reconfiguration `sendmail`) and how to fix any problems is beyond our scope here. It can be difficult depending on your system configuration, and it might be impossible to do without being a privileged user.

However, there is no need to use the `git send-email` command. You can use whatever email client you are accustomed to, such as Thunderbird, evolution, mutt, etc. But, if you do use a conventional email client, you must be careful not to screw up the patch in the mailing process:

* Turn off any html encoding and send plain ASCII text
* Turn off any line-wrapping or flowing

Most developers prefer to inline the patches directly into the email message rather than using attachments, which (besides requiring extra steps to view) can expose other email client idiosyncrasies. Even for very long patches, attachments may not be a good idea.

### Applying Patches

In a perfect world, applying patches would be as simple as doing the following:

```bash
$ git am 0002-This-is-the-second-commit.patch
```

Assuming you are in a branch that has not yet incorporated the patches' changes. This command is powerful; it not only applies the patches to the working copies in your project directories, but it also does a commit.

It is more than possible that one or more of the patches will fail due to conflicting lines of development between the patch sender and receiver. Such problems will have to be resolved one by one. For example, you may get a message like:

```bash
error: patch failed: file2:1
error: file2: patch does not apply
Patch failed at 0001.
```

When you have resolved this problem, do `git am --resolved`. If you would prefer to skip this patch, instead, do `git am --skip`.

You can also back off the patches and restore the original branch with:

```bash
$ git am --abort
```

You may prefer to do things by hand more cautiously. You can apply individual patches directly to your working copy. For example, you can try:

```bash
$ patch --dry-run < 0002-This-is-the-second-commit.patch
```

If no problems are encountered, run again without the `--dry-run` option. Then, you would have to run `git add` on the affected files and eventually do a `git commit`.

There is another lower-level command, `git apply`which is the basis of `git am`. If you do:

```bash
$ git apply --check 0002-This-is-the-second-commit.patch
```

it functions like `patch --dry-run`. It will not actually do the patch. If there are no problems, you can run again without the `--check option`. This patches the working files in your directories and updates the Index. You will still have to invoke `git add` and `git commit` eventually.

{% hint style="danger" %}
`git apply` Does not modify the index. You can also use `--cached` to apply the changes only to the index
{% endhint %}

### Changes Induced by \`git patch\`  Applying Commands

<table data-full-width="true"><thead><tr><th>Command</th><th>Source Files</th><th>Index</th><th>Commit Chain</th><th>References</th></tr></thead><tbody><tr><td><code>git am</code></td><td>Modified by patch</td><td>Updated to reflect patch</td><td>New commit object created and added to top of commit chain</td><td><strong>HEAD:</strong> points to new commit object</td></tr><tr><td><code>git apply</code></td><td>Modified by patch (unless the <strong>--check</strong> option specified)</td><td>Modified by patch (unless the <strong>--index</strong> option specified)</td><td>Unchanged</td><td>Unchanged</td></tr></tbody></table>

#### Review Lab 12.1 - Synchronizing with Patches

* First, initialize a repository, configuring it with a name, email address, etc. Then, add a couple of files to the project and commit them.

```bash
# Initialize the repository and put our name and email in the .config file.

echo -e "\n\n******** CREATING THE REPOSITORY AND CONFIGURING IT\n\n"

rm -rf git-test ; mkdir git-test ; cd git-test
git init
git config user.name "A Smart Guy"
git config user.email "asmartguy@linux.com"

echo -e "\n\n******** CREATING A COUPLE OF FILES AND ADDING THEM TO THE PROJECT AND COMMITTING\n\n"

echo file1 > file1
echo file2 > file2
git add file1 file2
git commit . -s -m "This is our first commit"


```

* Make a clone of the repository with `git clone` and change to the new directory.

```bash
echo -e "\n\n************ MAKING A NEW CLONE\n\n"

cd ..
git clone git-test git-newer
```

* Change a file in the copy and create a new file. Use `git add` and `git commit` to keep the repository up to date.

```bash
echo -e "\n\n************ MAKING CHANGES TO THE REPOSITORY*\n\n"

cd git-newer

echo another line >> file2
echo a third file > file3

echo -e "\n\n************ ADDING AND COMMITTING THE CHANGES\n\n"

git add file2 file3
git commit -s -m"modifications from the new clone"
```

* Produce a patch using `git format-patch`. Use the `-s` option to produce a signed-off line.

```bash
echo -e "\n\n************ PRODUCING THE PATCH*\n\n"

git format-patch -1 -s
mv 00* ..
```

* Go back to the original repository and first try to apply the patch with `git apply --check`. If that succeeds, apply the patch using `git am`.

```bash
echo -e "\n\n************ SEEING IF THE PATCH WORKED\n\n"

cd ..
cd git-test
git apply --check ../00*

echo -e "\n\n************* NOW APPLY THE PATCH\n\n"

git am ../00*
```

For an extra exercise, try to use `git send-email` to send the patch to yourself.

#### Knowledge Check 12.1

1. To breakout all commits in the main branch of a repo as patches, you can do:
   * [x] [`git format-patch --all main`](#user-content-fn-1)[^1]
   * [ ] `git format-patch main`
2. Which commands will generate a patch in proper form (Select all answers that apply):
   * [x] `diff -Nur source_tree modified_tree > the_patch`
   * [ ] `git diff -Nur source_tree modified_tree > the_patch`
   * [ ] `diff > the_patch`
   * [x] `git diff > the_patch`

[^1]: **`git format-patch --all main`**: This command is not valid. The `--all` option is used with `git format-patch` to format patches for all refs (branches and tags), but you cannot combine it directly with a branch name like `main`.
